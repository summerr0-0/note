<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-02-13T19:00:11.338744"><title>비즈니스로직 격리하기 | main</title><script type="application/json" id="virtual-toc-data">[{"id":"20e64ac1_154","level":0,"title":"비즈니스 로직이 프론트엔드에 있으면 왜 안좋을까","anchor":"#20e64ac1_154"},{"id":"ui","level":0,"title":"비즈니스 로직과 UI 기능 구현의 차이","anchor":"#ui"},{"id":"20e64ac1_248","level":0,"title":"비즈니스 로직 격리하기","anchor":"#20e64ac1_248"},{"id":"20e64ac1_283","level":0,"title":"관련 링크","anchor":"#20e64ac1_283"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="site.webmanifest"><meta name="msapplication-TileColor" content="#000000"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="비즈니스로직 격리하기 | main"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="main Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="비즈니스로직-격리하기.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="비즈니스로직 격리하기 | main"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "비즈니스로직-격리하기.html#webpage",
    "url": "비즈니스로직-격리하기.html",
    "name": "비즈니스로직 격리하기 | main",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "/#website",
    "url": "/",
    "name": "main Help"
}</script><!-- End Schema.org --></head><body data-id="비즈니스로직-격리하기" data-main-title="비즈니스로직 격리하기" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="javascript.md|javascript"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>main  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="비즈니스로직-격리하기" id="비즈니스로직-격리하기.md">비즈니스로직 격리하기</h1><section class="chapter"><h2 id="20e64ac1_154" data-toc="20e64ac1_154">비즈니스 로직이 프론트엔드에 있으면 왜 안좋을까</h2><div class="code-block" data-lang="javascript">
const Products = () =&gt; {
	const allProducts = useProducts(); // 상품 관련 커스텀 훅
	const user = useUser(); // 유저의 정보와 관련된 커스텀 훅

	const isCoat = product.type === &quot;coat&quot;;
	const isAutumn = dayjs().month() &gt;= 9 &amp;&amp; dayjs().month() &lt;= 11;
	//유저를 식별하는 로직
	const isRecommended = isCoat &amp;&amp; user.gender === &quot;female&quot; &amp;&amp; isAutumn;
	
	// 코트 상단 노출을 위해 분리 해줌
	const { coats, products } = allProducts.reduce((acc, product) =&gt; {
		if (product.type === &quot;coat&quot;) {
			return { ...acc, coats: acc.coats.concat(product) } }
		}
		return { ...acc, products: acc.products.concat(product) } }
	}, { coats: [], products: [] })

	return (
		&lt;&gt;
			{isRecommended
				? &lt;&gt;
						{[coats, products].flatMap((product) =&gt; &lt;ProductCard product={product} /&gt;)}
					&lt;/&gt;
				: allProducts((product) =&gt; &lt;ProductCard product={product} /&gt;)}
			}
		&lt;/&gt;
	)
}

const ProductCard = ({ product, isRecommended }) =&gt; {
	const price = isRecommended ? product.price * 0.95 : product.price;
	
	return /** 상품 카드 관련 코드 */
}

</div><ul class="list _ul" id="20e64ac1_156"><li class="list__item" id="20e64ac1_157"><p>해당 로직을 통해 구매할 경우 5% 세일을 해주는 로직</p></li><li class="list__item" id="20e64ac1_158"><p>해당 로직의 문제점 </p><ul class="list _ul" id="20e64ac1_159"><li class="list__item" id="20e64ac1_160"><p id="20e64ac1_161">어떤 상품이 추천되어야 하는지에 대한 책임이 Product와 ProductCard 양쪽으로 분산되어 관리 포인트가 늘어났다.</p></li><li class="list__item" id="20e64ac1_162"><p id="20e64ac1_163">만약 추천 대상이나 조건이 변경될 경우 두 컴포넌트 모두 변경의 대상이 된다</p></li><li class="list__item" id="20e64ac1_164"><p id="20e64ac1_165">Products는 상품의 목록을 렌더링 하는 것이 가장 핵심적인 임무인 컴포넌트</p></li><li class="list__item" id="20e64ac1_166"><p id="20e64ac1_167">이 컴포넌트는 상품에 대한 정보를 서버로부터 받아와서 역할</p></li><li class="list__item" id="20e64ac1_168"><p id="20e64ac1_169">컴포넌트는 단순하게 그리기만 할 수록 좋은 컴포넌트다</p></li><li class="list__item" id="20e64ac1_170"><p id="20e64ac1_171">여기에 비즈니스적인 요구 사항인 &lsquo;추천&rsquo;에 대한 로직의 분량이 더 커보일 수록 본질에서 멀어지게 됩니다.</p></li></ul></li></ul><ul class="list _ul" id="20e64ac1_172"><li class="list__item" id="20e64ac1_173"><p>만약 웹 애플리케이션 뿐만 아니라 앱에서도 동일한 로직을 구현해야 한다면 앱에서도 동일한 로직을 재작성해야 합니다. 또한 위에 언급한 문제들을 앱 쪽에서도 동일하게 겪게 되겠죠.</p></li><li class="list__item" id="20e64ac1_174"><p>무엇보다도 핵심 비즈니스 로직이 외부로 노출되면서 누군가 프론트엔드 측 요청을 조작하여 부당하게 5% 할인을 챙겨갈 수 있는 보안 상의 위험성 또한 생길 수 있겠습니다.</p></li></ul><div class="code-block" data-lang="javascript">

const Products = () =&gt; {
	const products = useProducts();

	return products.map((product) =&gt; &lt;ProductCard product={product} /&gt;)
}

const ProductCard = ({ product }) =&gt; {
	return (
		&lt;li&gt;
			&lt;span&gt;정상가: {product.price.original}&lt;/span&gt;
			&lt;span&gt;할인가: {product.price.discounted}&lt;/span&gt;
		&lt;/li&gt;
	)
}

</div><ul class="list _ul" id="20e64ac1_176"><li class="list__item" id="20e64ac1_177"><p>프론트 측에서 유저 식별 정보를 파악할 필요가 없어졌습니다.</p></li><li class="list__item" id="20e64ac1_178"><p>백엔드 API에서 products가 전달 될 때 애초에 추천 상품이 내려도록 함 </p><ul class="list _ul" id="20e64ac1_179"><li class="list__item" id="20e64ac1_180"><p>별도로 상품을 재배열하는 로직을 작성할 필요가 없어짐</p></li></ul></li><li class="list__item" id="20e64ac1_181"><p>isRecommended 사라지고 일반적인 &lsquo;정상가&rsquo;와 &lsquo;할인가&rsquo;라는 개념을 사용하도록 응답 객체를 구성해 모든 할인 이벤트에서 재사용 할 수 있게 됨</p></li><li class="list__item" id="20e64ac1_182"><p>할인 로직을 프론트 측에서 작성하지 않으므로 보안 상의 위험이 사라지게 됨</p></li><li class="list__item" id="20e64ac1_183"><p>역할이 명확해진다 </p><ul class="list _ul" id="20e64ac1_184"><li class="list__item" id="20e64ac1_185"><p>프론트엔드는 데이터를 받아 화면에 렌더링하는 역할</p></li><li class="list__item" id="20e64ac1_186"><p>백엔드는 DB에서 데이터를 가져와 비즈니스 요구 사항에 맞게 가공하는 역할</p></li></ul></li></ul></section><section class="chapter"><h2 id="ui" data-toc="ui">비즈니스 로직과 UI 기능 구현의 차이</h2><ul class="list _ul" id="20e64ac1_187"><li class="list__item" id="20e64ac1_188"><p id="20e64ac1_189">비즈니스로직</p><ul class="list _ul" id="20e64ac1_190"><li class="list__item" id="20e64ac1_191"><p>비즈니스적인 요구사항</p></li><li class="list__item" id="20e64ac1_192"><p>단순한 버튼클릭이더라도 여러 조건들이 연결되면서 복잡해진다</p></li></ul></li><li class="list__item" id="20e64ac1_193"><p id="20e64ac1_194">비즈니스 로직 예시</p><ul class="list _ul" id="20e64ac1_195"><li class="list__item" id="20e64ac1_196"><p id="20e64ac1_197">가격 할인 로직</p><ul class="list _ul" id="20e64ac1_198"><li class="list__item" id="20e64ac1_199"><p>매월 첫 구매 고객에게 10% 할인 제공</p></li></ul></li><li class="list__item" id="20e64ac1_200"><p id="20e64ac1_201">재고 관리 로직</p><ul class="list _ul" id="20e64ac1_202"><li class="list__item" id="20e64ac1_203"><p>특정 사이즈가 품절이면 예약주문 옵션 노출</p></li></ul></li><li class="list__item" id="20e64ac1_204"><p id="20e64ac1_205">장바구니는 비즈니스 로직일까?</p><ul class="list _ul" id="20e64ac1_206"><li class="list__item" id="20e64ac1_207"><p>장바구니는 대부분의 전자상거래 서비스에서 사용하는 일반적인 개념. 장바구니가 동작하는 방식은 비슷하다</p></li><li class="list__item" id="20e64ac1_208"><p>비즈니스 규칙은 해당 서비스에서 운영하는 특별한 규칙이다.</p></li></ul></li><li class="list__item" id="20e64ac1_209"><p id="20e64ac1_210">비즈니스 로직은 경우에 따라 백엔드도 프론트도 할 수 있다</p></li></ul></li><li class="list__item" id="20e64ac1_211"><p id="20e64ac1_212">UI 로직</p></li><li class="list__item" id="20e64ac1_213"><p id="20e64ac1_214">UI 로직은 그 자체로는 특정 비즈니스에 구속되지 않고, 사용자와 시스템 간의 기본적인 상호작용을 위한 보다 일반적인 차원에서의 기능 구현 코드입니다.</p></li><li class="list__item" id="20e64ac1_215"></li><li class="list__item" id="20e64ac1_216"><p id="20e64ac1_217">UI기능 구현의 예시</p><ul class="list _ul" id="20e64ac1_218"><li class="list__item" id="20e64ac1_219"><p id="20e64ac1_220">버튼 클릭</p><ul class="list _ul" id="20e64ac1_221"><li class="list__item" id="20e64ac1_222"><p>더보기 버튼 클릭하면 페이지 로드</p></li></ul></li><li class="list__item" id="20e64ac1_223"><p id="20e64ac1_224">페이지 스크롤</p><ul class="list _ul" id="20e64ac1_225"><li class="list__item" id="20e64ac1_226"><p>페이지 스크롤을 아래까지 내리면 다른 글 추천</p></li></ul></li><li class="list__item" id="20e64ac1_227"><p id="20e64ac1_228">폼 제출</p><ul class="list _ul" id="20e64ac1_229"><li class="list__item" id="20e64ac1_230"><p>제출하기 버튼 누르면 정보가 전달</p></li></ul></li></ul></li></ul><p id="20e64ac1_231">반면, 비즈니스 로직은 주로 특정한 상황이나 조건에 따라 다르게 동작하도록 설계된, 말 그대로 어떠한 비즈니스에 맞춰진 작업 흐름입니다. 종종 복잡하고, 비즈니스의 성공에 중요한 전략적 결정에 영향을 미치기도 합니다. 그렇기에 기능 상으로는 다소 호환성이 떨어지고, 코드의 원래 맥락으로 부터 떨어져 다른 곳으로 옮겨가기 힘들다는 특성을 가지고 있습니다.</p><p id="20e64ac1_232">여기서 매우 흥미로운 점은 <span class="control" id="20e64ac1_233">대부분의 비즈니스 로직은 사실 백엔드 API와 DB 사이 어딘가에서 다뤄지게 되고, 또 그래야만 합니다</span>. 프론트엔드에서 결제 로직의 핵심적인 부분을 처리한다면 그건 여러 의미로 매우 잘못된 설계라고 볼 수 있습니다. 유저 클라이언트에서 알아서는 안되는 정보입니다.</p><p id="20e64ac1_234">그럼에도 불구하고 프론트엔드에서 비즈니스 로직에 대한 이해도를 갖추고 있어야 하는 이유는 <span class="control" id="20e64ac1_235">1) 비즈니스 로직을 알아보고 UI 로부터 적절히 분리하기 위해서 2) 비즈니스 로직을 알아보고 백엔드 API 단으로 적절히 격리하기 위해서</span> 라고 보아도 무방합니다.</p><p id="20e64ac1_236">더 나아가 비즈니스 로직과 UI가 잘 분리되어 있는 제품을 설계할 수 있게 된다면 훨씬 더 확장성 있고 일할 맛 나는 업무 환경을 갖추게 될 수도 있습니다. 생각만 해도 기분이 좋네요!</p><ul class="list _ul" id="20e64ac1_237"><li class="list__item" id="20e64ac1_238"><p>소프트 웨어는 부드러움을 지니도록 만들어졌다</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="20e64ac1_239"><p id="20e64ac1_240">소프트웨어는 '부드러움을 지니도록' 만들어졌다. 소프트웨어를 만든 이유는 기계의 행위를 쉽게 변경할 수 있도록 하기 위해서다. 만약 기계의 행위를 바꾸는 일을 어렵게 만들고자 했다면, 우리는 소프트웨어가 아니라 하드웨어라고 불렸을 것이다</p></aside><ul class="list _ul" id="20e64ac1_241"><li class="list__item" id="20e64ac1_242"><p>비즈니스로직과 액션 </p><ul class="list _ul" id="20e64ac1_243"><li class="list__item" id="20e64ac1_244"><p>순수성을 깨는 존재들</p></li><li class="list__item" id="20e64ac1_245"><p>순수성을 보장하기 위한 리액트 custom hook</p></li><li class="list__item" id="20e64ac1_246"><p>액션 - 전염이 된다 *</p></li></ul></li></ul><p id="20e64ac1_247">제어권이 위에 있다 함수도 객체다 컴포넌트 함수다 컴포넌트 컴파운드 패턴</p></section><section class="chapter"><h2 id="20e64ac1_248" data-toc="20e64ac1_248">비즈니스 로직 격리하기</h2><ol class="list _decimal" id="20e64ac1_249" type="1"><li class="list__item" id="20e64ac1_250"><p>추출과 추상화를 구분하기</p></li></ol><ul class="list _ul" id="20e64ac1_251"><li class="list__item" id="20e64ac1_252"><p id="20e64ac1_253">추출 : 코드의 일부를 물리적으로 분리</p><ul class="list _ul" id="20e64ac1_254"><li class="list__item" id="20e64ac1_255"><p>긴 함수를 여러 함수로 나누는 것</p></li><li class="list__item" id="20e64ac1_256"><p>코드의 양을 줄이고 쉽게 관리하기 쉽게 만든다</p></li></ul></li><li class="list__item" id="20e64ac1_257"><p id="20e64ac1_258">추상화 : 코드의 일부를 보다 일반화 된 형태로 개념화 하는 것</p><ul class="list _ul" id="20e64ac1_259"><li class="list__item" id="20e64ac1_260"><p>코드가 무엇을 하는지 왜 필요한지 명확하게 이해하는 것</p></li><li class="list__item" id="20e64ac1_261"><p>적절한 추상화는 간결한 코드가 된다</p></li><li class="list__item" id="20e64ac1_262"><p>좋은 추상화는 모듈성을 만든다</p></li></ul></li><li class="list__item" id="20e64ac1_263"><p id="20e64ac1_264">모둘 : 모드의 동립된 부분</p><ul class="list _ul" id="20e64ac1_265"><li class="list__item" id="20e64ac1_266"><p>모듈성 : 모듈들이 잘 연결되고 각각 독립적으로 기능할 수 있도록 하는 속성</p></li><li class="list__item" id="20e64ac1_267"><p>모듈들은 재사용 가능해야하고 교체가능해야 하고 다른 모듈에 영향을 최소화 해야 한다</p></li></ul></li><li class="list__item" id="20e64ac1_268"><p id="20e64ac1_269">좋은 추상화란 코드 뒤에 숨은 의도를 파악하고 쓰임새에 맞도록 적절한 단위와 형태를 만들어 나가는 과정</p></li><li class="list__item" id="20e64ac1_270"><p id="20e64ac1_271">의미를 잘 드러낸 코드는 읽기도, 수정하기도 좋은 코드가 될 확률이 높습니다. 하나의 문장에 하나의 의미만을 담</p></li><li class="list__item" id="20e64ac1_272"><p id="20e64ac1_273">MVC도 추상화</p><ul class="list _ul" id="20e64ac1_274"><li class="list__item" id="20e64ac1_275"><ol class="list _decimal" id="20e64ac1_276" type="1"><li class="list__item" id="20e64ac1_277"><p>데이터 영역과 2) 그것을 보여주는 영역 3) 둘 사이에 가공 로직을 담당하는 무언가가 필요하다는 통찰</p></li></ol></li></ul></li></ul><ol class="list _decimal" id="20e64ac1_278" type="1" start="2"><li class="list__item" id="20e64ac1_279"><p id="20e64ac1_280">캡슐화는 숨기는것</p></li><li class="list__item" id="20e64ac1_281"><p id="20e64ac1_282">추상화와 어댑터</p></li></ol></section><section class="chapter"><h2 id="20e64ac1_283" data-toc="20e64ac1_283">관련 링크</h2><ul class="list _ul" id="20e64ac1_284"><li class="list__item" id="20e64ac1_285"><p><a href="https://muchtrans.com/translations/simple-made-easy.ko.html" id="20e64ac1_286" data-external="true" rel="noopener noreferrer">simple 과 easy 는 다르다</a></p></li><li class="list__item" id="20e64ac1_287"><p><a href="https://github.com/falsy/react-with-clean-architecture/blob/master/readme-ko.md" id="20e64ac1_288" data-external="true" rel="noopener noreferrer">Sample code of React with Clean architecture</a></p></li><li class="list__item" id="20e64ac1_289"><p><a href="https://uchanlee.dev/clean-architecture/clean-architecture-for-frontend/" id="20e64ac1_290" data-external="true" rel="noopener noreferrer">프론트엔드에서 클린 아키텍처 적용하기</a></p></li><li class="list__item" id="20e64ac1_291"><p><a href="https://speakerdeck.com/soyoung210/heonjibjulge-saejibdao-riaegteu-peurojegteu-gujojojeong" id="20e64ac1_292" data-external="true" rel="noopener noreferrer">헌집줄게, 새집다오 - 리액트 프로젝트 구조조정</a></p></li><li class="list__item" id="20e64ac1_293"><p><a href="https://speakerdeck.com/soyoung210/clean-architecture-in-banksalad" id="20e64ac1_294" data-external="true" rel="noopener noreferrer">Clean Architecture-in Banksalad</a></p></li><li class="list__item" id="20e64ac1_295"><p><a href="https://ahnheejong.name/articles/package-structure-with-the-principal-of-locality-in-mind/" id="20e64ac1_296" data-external="true" rel="noopener noreferrer">지역성의 원칙을 고려한 패키지 구조: 기능별로 나누기</a></p></li><li class="list__item" id="20e64ac1_297"><p><a href="https://enterprisecraftsmanship.com/posts/what-is-domain-logic/" id="20e64ac1_298" data-external="true" rel="noopener noreferrer">What is domain logic?</a></p></li><li class="list__item" id="20e64ac1_299"><p><a href="https://medium.com/@shinbaek89/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-business-logic%EC%9D%98-%EB%B6%84%EB%A6%AC-adc10ae881ab" id="20e64ac1_300" data-external="true" rel="noopener noreferrer">프론트엔드 아키텍처: Business Logic의 분리</a></p></li><li class="list__item" id="20e64ac1_301"><p><a href="https://smartstudio.tech/bringing-consistency-to-broken-ui-layer/" id="20e64ac1_302" data-external="true" rel="noopener noreferrer">망가진 UI 아키텍처 일관성 &lsquo;함께 고치기&rsquo;</a></p></li><li class="list__item" id="20e64ac1_303"><p><a href="https://refactor-like-a-superhero.vercel.app/en" id="20e64ac1_304" data-external="true" rel="noopener noreferrer">Refactor Like A Superhero</a></p></li></ul></section><div class="last-modified">Last modified: 13 2월 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="javascript.html" class="navigation-links__prev">javascript</a><a href="변하는-것과-변하지-않는-것-구분하기.html" class="navigation-links__next">변하는 것과 변하지 않는 것 구분하기</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>
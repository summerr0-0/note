<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-02-22T22:52:43.405581"><title>스프링 삼각형 | main</title><script type="application/json" id="virtual-toc-data">[{"id":"ioc-di","level":0,"title":"IOC/DI","anchor":"#ioc-di"},{"id":"aop","level":0,"title":"AOP","anchor":"#aop"},{"id":"psa","level":0,"title":"PSA","anchor":"#psa"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="site.webmanifest"><meta name="msapplication-TileColor" content="#000000"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="스프링 삼각형 | main"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="main Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="스프링-삼각형.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="스프링 삼각형 | main"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "스프링-삼각형.html#webpage",
    "url": "스프링-삼각형.html",
    "name": "스프링 삼각형 | main",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "/#website",
    "url": "/",
    "name": "main Help"
}</script><!-- End Schema.org --></head><body data-id="스프링-삼각형" data-main-title="스프링 삼각형" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="architecture.md|architecture///book-스프링입문을-위한-자바-객체-지향의-원리와-이해.md|book-스프링입문을 위한 자바 객체 지향의 원리와 이해"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>main  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="스프링-삼각형" id="스프링-삼각형.md">스프링 삼각형</h1><section class="chapter"><h2 id="ioc-di" data-toc="ioc-di">IOC/DI</h2><ul class="list _ul" id="9a281427_118"><li class="list__item" id="9a281427_119"><p>객체간의 의존성을 외부에 주입</p></li><li class="list__item" id="9a281427_120"><p>스프링 없을 때 </p><ul class="list _ul" id="9a281427_121"><li class="list__item" id="9a281427_122"><p>생성자 주입 </p><ul class="list _ul" id="9a281427_123"><li class="list__item" id="9a281427_124"><p>객체를 생성할 때 생성자를 통해 의존성을 주입</p></li></ul></li><li class="list__item" id="9a281427_125"><p>속성을 통한 주입 (set) </p><ul class="list _ul" id="9a281427_126"><li class="list__item" id="9a281427_127"><p>Setter 메서드를 통해 의존성을 주입하는 방식</p></li></ul></li></ul></li><li class="list__item" id="9a281427_128"><p>스프링을 통해서 </p><ul class="list _ul" id="9a281427_129"><li class="list__item" id="9a281427_130"><p>XML 파일을 통한 주입 </p><ul class="list _ul" id="9a281427_131"><li class="list__item" id="9a281427_132"><p><code class="code" id="9a281427_133">XML</code>에 bean 정의와 의존성 주입 정보를 명시하여, 스프링 컨테이너가 객체를 생성하고 의존성을 주입</p></li></ul></li><li class="list__item" id="9a281427_134"><p>XML 파일을 통해 속성 주입 </p><ul class="list _ul" id="9a281427_135"><li class="list__item" id="9a281427_136"><p><code class="code" id="9a281427_137">&lt;property&gt;</code> 태그를 사용하여 속성(Setter) 주입을 하는 방식</p></li></ul></li><li class="list__item" id="9a281427_138"><p><code class="code" id="9a281427_139">@Autowired 를 통한 속성 주입</code></p><ul class="list _ul" id="9a281427_140"><li class="list__item" id="9a281427_141"><p>타입에 기반하여 자동으로 매칭되는 빈을 찾아 주입</p></li></ul></li><li class="list__item" id="9a281427_142"><p><code class="code" id="9a281427_143">@Resource</code> 를 통한 속성 주입 </p><ul class="list _ul" id="9a281427_144"><li class="list__item" id="9a281427_145"><p>이름이나 타입에 기반해 스프링이 의존성을 주입</p></li><li class="list__item" id="9a281427_146"><p><code class="code" id="9a281427_147">@Autowired</code>와 비슷하지만, 주로 이름을 기반으로 의존성을 주입할 때 사용</p></li></ul></li></ul></li></ul><p id="9a281427_148">+) <code class="code" id="9a281427_149">@Autowired</code> 나 <code class="code" id="9a281427_150">@Resource</code> (필드주입)을 지양하는 이유 &rarr; 순환참조 발견이 어렵다</p><div class="code-block" data-lang="none">
@Service
public class ClassA {
    @Autowired
    private ClassB classB;
}

@Service
public class ClassB {
    @Autowired
    private ClassA classA;
}
</div><ul class="list _ul" id="9a281427_152"><li class="list__item" id="9a281427_153"><p>상황 </p><ul class="list _ul" id="9a281427_154"><li class="list__item" id="9a281427_155"><p>두 개 이상의 빈이 서로를 참조하고 있는상태</p></li><li class="list__item" id="9a281427_156"><p>한 빈(A)의 초기화 과정에서 다른 빈(B)을 필요로 함</p></li><li class="list__item" id="9a281427_157"><p>다른 빈(B) 역시 아직 초기화과정에서 첫 번째 빈(A)을 필요로 함</p></li></ul></li><li class="list__item" id="9a281427_158"><p>필드 주입 </p><ul class="list _ul" id="9a281427_159"><li class="list__item" id="9a281427_160"><p>컨테이너가 빈을 먼저 생성한 후 리플렉션을 사용해서 의존성을 필드에 주입</p></li><li class="list__item" id="9a281427_161"><p>실제 사용 시점에 의존성 주입을 하기 때문에 런타임 시점에 순환참조가 발생함 (!!)</p></li></ul></li><li class="list__item" id="9a281427_162"><p>생성자 주입 </p><ul class="list _ul" id="9a281427_163"><li class="list__item" id="9a281427_164"><p>컨테이너가 빈을 생성할때 의존성도 같이 주입됨</p></li><li class="list__item" id="9a281427_165"><p>컴파일 시점에 순환참조를 발견할 수 있다</p></li></ul></li></ul></section><section class="chapter"><h2 id="aop" data-toc="aop">AOP</h2><ul class="list _ul" id="9a281427_166"><li class="list__item" id="9a281427_167"><p>공통적으로 사용되는 기능을 분리</p></li><li class="list__item" id="9a281427_168"><p>스프링 AOP는 인터페이스 기반이다</p></li><li class="list__item" id="9a281427_169"><p>스프링 AOP는 프록시 기반이다</p></li><li class="list__item" id="9a281427_170"><p>스프링 AOP는 런타임 기반이다</p></li><li class="list__item" id="9a281427_171"><p>용어 </p><ul class="list _ul" id="9a281427_172"><li class="list__item" id="9a281427_173"><p>Aspect </p><ul class="list _ul" id="9a281427_174"><li class="list__item" id="9a281427_175"><p>여러개의 Advice와 여러개의 Pointcut의 결합체를 의미</p></li><li class="list__item" id="9a281427_176"><p>관심사를 모듈화 한것</p></li><li class="list__item" id="9a281427_177"><p>ex) 로그 AOP </p><ul class="list _ul" id="9a281427_178"><li class="list__item" id="9a281427_179"><p><code class="code" id="9a281427_180">LoggingAspect</code> 클래스는 <code class="code" id="9a281427_181">@Aspect</code> 어노테이션을 사용하여 정의됨</p></li><li class="list__item" id="9a281427_182"><p>Aspect 클래스 내에는 실행 전후에 로그를 출력하는 Advice 메소드들이 정의되어 있다</p></li></ul></li></ul></li><li class="list__item" id="9a281427_183"><p>Advisor </p><ul class="list _ul" id="9a281427_184"><li class="list__item" id="9a281427_185"><p>한개의 Adcice + 한개의 Pointcut</p></li><li class="list__item" id="9a281427_186"><p>어떤 Advice가 어떤 Point에 적용될지 정의</p></li></ul></li><li class="list__item" id="9a281427_187"><p>Advice </p><ul class="list _ul" id="9a281427_188"><li class="list__item" id="9a281427_189"><p>pointcut에 적용할 로직(메서드)</p></li><li class="list__item" id="9a281427_190"><p>pointcut에 언제, 무엇을 적용할지</p></li><li class="list__item" id="9a281427_191"><p>Before , Around, After..</p></li><li class="list__item" id="9a281427_192"><p>ex ) </p><ul class="list _ul" id="9a281427_193"><li class="list__item" id="9a281427_194"><p>메서드들에 <code class="code" id="9a281427_195">@Before</code>, <code class="code" id="9a281427_196">@After</code> 등 설정</p></li><li class="list__item" id="9a281427_197"><p><code class="code" id="9a281427_198">@Before</code> 대상 메소드 실행 전에 로그를 출력</p></li><li class="list__item" id="9a281427_199"><p><code class="code" id="9a281427_200">@After</code> 대상 메소드 실행 후에 로그를 출력합니다</p></li></ul></li></ul></li><li class="list__item" id="9a281427_201"><p>JoinPoint </p><ul class="list _ul" id="9a281427_202"><li class="list__item" id="9a281427_203"><p>프로그램 실행 중 Aspect에 의해 삽입될 수 있는 곳</p></li><li class="list__item" id="9a281427_204"><p>Advice가 적용되는 대상 객체</p></li><li class="list__item" id="9a281427_205"><p>이 객체의 메소드 호출시 AOP가 Advice 코드를 삽입해서 실행된다</p></li><li class="list__item" id="9a281427_206"><p>SomeService.findById 메서드 호출시점 &rarr; Advice가 실행되는 JoingPoint</p></li></ul></li><li class="list__item" id="9a281427_207"><p>Pointcut </p><ul class="list _ul" id="9a281427_208"><li class="list__item" id="9a281427_209"><p>Aspect 적용할 대상을 지정</p></li><li class="list__item" id="9a281427_210"><p>JoinPoint의 부분집합</p></li><li class="list__item" id="9a281427_211"><p>표현식으로 특정 메소드나 클래스에 대한 조건을 정의할 수 있다</p></li><li class="list__item" id="9a281427_212"><p><code class="code" id="9a281427_213">[접근제한자패턴] 리턴타입패턴 [패키지&amp;클래스패턴]메서드이름패턴(파라미터패턴)[throws 예외 패턴]</code></p></li><li class="list__item" id="9a281427_214"><p>ex) </p><ul class="list _ul" id="9a281427_215"><li class="list__item" id="9a281427_216"><p>어떤 메소드들이 로그 출력 기능의 대상이 되는지</p></li><li class="list__item" id="9a281427_217"><p><code class="code" id="9a281427_218">@Before (&quot;execution(* com.org.demo.service.*.*(..))&quot;)</code></p><ul class="list _ul" id="9a281427_219"><li class="list__item" id="9a281427_220"><p>service 패키지 내의 모든 클래스의 모든 메소드에 대해 적용</p></li></ul></li></ul></li></ul></li></ul></li></ul></section><section class="chapter"><h2 id="psa" data-toc="psa">PSA</h2><ul class="list _ul" id="9a281427_221"><li class="list__item" id="9a281427_222"><p>일관성 있는 서비스 추상화</p></li><li class="list__item" id="9a281427_223"><p>JDBC </p><ul class="list _ul" id="9a281427_224"><li class="list__item" id="9a281427_225"><p>오라클을 사용하든, MySQL을 사용하든 공통된 방식으로 코드를 작성할 수 있다</p></li><li class="list__item" id="9a281427_226"><p>어댑터 패턴을 활용</p></li></ul></li></ul></section><div class="last-modified">Last modified: 22 2월 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="book-스프링입문을-위한-자바-객체-지향의-원리와-이해.html" class="navigation-links__prev">book-스프링입문을 위한 자바 객체 지향의 원리와 이해</a><a href="3-자바와-객체지향.html" class="navigation-links__next">3. 자바와 객체지향</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>